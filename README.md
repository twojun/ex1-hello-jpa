# JPA 이론 학습

# Chapter 1. JPA Basic
1. EntityManager는 애플리케이션 로딩 시점에 1개만 생성해서 모든 영역에서 공유하며 사용한다.
2. EntityManager는 스레드 간 공유하지 않는다.
3. JPA 내부에서의 데이터 수정은 Transaction 내부에서 진행된다.</br></br></br>


4. JPQL(Java Persistence Query Language)
- 실제 물리적 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 하는 객체지향 쿼리 언어를 의미힌다.
- 특정 데이터베이스 테이블을 대상으로 쿼리를 날리면 해당 데이터베이스에 종속적인 설계로 이루어진다 하지만 JPQL를
  사용함으로써 특정 DB에 종속적이지 않은 쿼리를 작성할 수 있다.
- JPQL를 통해 엔티티 객체를 중심으로 개발할 수 있다.</br></br></br></br>





# Chapter 2. Persistence Context
1. EntityManagerFactory & EntityManager
- EntityManagerFactory를 통해 고객의 요청이 올 때마다 새로운 EntityManager를 생성한다.
- EntityManager는 내부적으로 데이터베이스 커넥션을 사용해서 데이터베이스와 통신하게 된다.</br></br></br>



2. Persistence Context?
- 엔티티를 영구적으로 저장하는 환경이라는 뜻을 가지고 있으며 가시적이지 않은 논리적인 개념이다.</br></br>
- EntityManager를 통해 영속성 컨텍스트에 접근할 수 있다.</br></br>
- em.persist(entity); 코드의 경우 실제 데이터베이스에 저장한다는 것이 아니라 영속성 컨텍스트를 통해서
  해당 엔티티를 영속화(영속성 컨텍스트에 저장)한다는 의미를 가지고 있다.</br></br></br>



3. 엔티티의 생명주기</br>
(1) 비영속(new/transient) 상태
- 영속성 컨텍스트와 전혀 연관 없는 상태</br></br>
(2) 영속(managed) 상태
- 영속성 컨텍스트에 의해 관리되는 상태</br></br>
(3) 준영속(detached) 상태
- 영속성 컨텍스트에서 저장되었다가 분리된 상태</br></br>
(4) 삭제(Removed) 상태
- 삭제된 상태</br></br></br>


4. Persistence Context의 이점</br>
4-1. 1차 캐시</br></br
(1) 엔티티를 영속화하거나 처음 조회한다면 영속성 컨텍스트 내부에 1차 캐시로 해당 엔티티에 대한 스냅샷 정보를 저장해둔다. </br></br>
(2) 1차 캐시에 엔티티가 없다면 직접 데이터베이스를 조회하여 관련 엔티티를 1차 캐시에 저장한다.</br></br></br>


4-2. 영속 엔티티의 동일성 보장</br>
(1) JPA가 동일 트랜잭션 내부에서 영속화된 엔티티의 동일성을 보장해준다. 마치 자바 컬렉션에서 똑같은 참조 주소를 가지고 있는 객체에 대해 == 비교를 한 것과 동일한 상황이다.</br></br>


4-3. 트랜잭션을 지원하는 쓰기 지연</br>
(1) 영속성 컨텍스트 내부엔 쓰기 지연 저장소라는 공간이 존재한다. </br></br>
(2) 엔티티가 영속화되는 순간 연관된 INSERT SQL를 쓰기 지연 저장소에 보관한다. </br></br>
(3) 트랜잭션을 커밋하는 순간 flush가 발생되어 쓰기 지연 저장소에 보관되어 있던 INSERT SQL이 실제 DB로 전송되고 커밋이 진행된다. </br></br></br>


4-4. 엔티티 수정 시 발생하는 변경 감지(Dirty checking)</br>
(1) 트랜잭션 커밋 시점에 내부적으로 Flush가 호출된다.</br></br>
(2) Flush가 발생하면, 해당 엔티티의 초기 스냅샷(영속성 컨텍스트에 처음 영속화됐을 당시의 데이터)과 엔티티의 수정 사항을 비교한다.</br></br>
(3) 엔티티의 스냅샷과 수정 사항을 비교해서 변경사항이 존재한다면 쓰기 지연 저장소에 UPDATE SQL를 저장해두고 이를 실제 DB에 보내면서 커밋이 진행된다.</br></br>
(4) 이러한 일련의 과정들을 변경 감지(Dirty checking)이라고 한다.</br></br></br></br></br>




5. Flush(플러시)란 무엇일까?</br>
(1) 플러시는 영속성 컨텍스트의 변경 내용과 실제 물리적 데이터베이스의 내용이 일치하도록 반영하는 작업을 의미하고 있다.</br></br>
(2) 일반적으로 데이터베이스 커밋 시점에 플러시가 발생하게 된다.</br></br>
(3) 트랜잭션이라는 작업 단위가 중요하고, 커밋 직전에만 데이터베이스와 동기화해주면 된다는 특징이 있다.</br></br></br>


5-1. 영속성 컨텍스트를 플러시하는 방법?</br>
(1) em.flush()</br></br>
(2) 트랜잭션 커밋 시점</br></br>
(3) JPQL 쿼리를 날린 경우 </br></br></br>


5-2. 플러시 모드 옵션</br>
(1) FlushModeType.AUTO (기본값)
- 커밋, 쿼리를 실행할 때 플러시 실행 </br></br>

(2) FlushModeType.COMMIT
- 커밋 시점에서만 플러시 실행</br></br></br></br></br>




6. 준영속 상태</br>
(1) 영속 상태의 엔티티가 영속성 컨텍스트에서 분리되는 것을 말한다. 이럴 경우 영속성 컨텍스트가 제공하는 기능(변경 감지 등)을 사용할 수 없게 된다. </br></br>

6-1. 준영속 상태로 전환하는 방법</br>
(1) em.detach(entity);
- 특정 엔티티만 준영속 상태로 전환 </br></br>
(2) em.clear();
- 영속성 컨텍스트를 완전히 초기화</br></br>
(3) em.close();
- 영속성 컨텍스트를 종료한다.</br></br></br></br></br>






# Chapter 3. Entity Mapping
JPA에서 중요한 부분 2가지 : JPA 동작 방식(영속성 컨텍스트) 이해, 설계적인 측면에서 객체와 데이터베이스 테이블을 정확히 매핑하는 것 </br></br>
객체와 테이블 매핑 : @Entity, @Table</br>
필드와 컬럼 매핑 : @Column</br>
기본 키 매핑 : @Id</br>
연관관계 매핑 : @ManyToOne, @JoinColumn ... 등</br></br>

6-1. 객체와 테이블 매핑</br>
(1) @Entity가 붙은 클래스는 JPA가 관리하는 엔티티라고 부른다.</br></br>
(2) JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션이 필수이다.</br></br>
(3) JPA 스펙 상, 기본 생성자(public, protected)가 필수적이다.</br></br></br></br>






# Chapter 4. 연관관계 Mapping : 1:1 1:n n:1 n:n
(1) 연관관계 매핑에서 가장 중요한 것? : 객체와 테이블 연관관계의 차이를 이해, 객체의 참조와 테이블 외래 키를 정확히 매핑하는 것</br></br>
(2) 주요 용어 : 단방향, 양방향,  1:1 1:n n:1 n:n, 연관관계의 주인 설정</br></br></br>



4-1. 객체를 테이블에 맞추어 데이터 중심으로 모델링 시 객체 간의 협력 관계를 만들 수 없다.</br></br>
(1) 테이블은 외래 키로 JOIN을 통해 연관 테이블을 탐색한다.</br></br>
(2) 하지만 객체는 참조를 사용해서 연관된 객체를 탐색하게 된다(객체와 테이블 간의 패러다임 불일치라는 큰 간격이 발생한다)</br></br>
(3) 어떻게 해결할 수 있을까? : 객체의 참조와 데이터베이스 테이블의 외래 키를 매핑해서 연관관계를 설정함으로써 패러다임 불일치를 해결한다.</br></br></br>


4-2. 단방향 연관관계 




