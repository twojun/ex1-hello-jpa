# JPA 이론 학습

# Chapter 1. JPA Basic
1. EntityManager는 애플리케이션 로딩 시점에 1개만 생성해서 모든 영역에서 공유하며 사용한다.
2. EntityManager는 스레드 간 공유하지 않는다.
3. JPA 내부에서의 데이터 수정은 Transaction 내부에서 진행된다.</br></br></br>


4. JPQL(Java Persistence Query Language)
- 실제 물리적 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 하는 객체지향 쿼리 언어를 의미힌다.
- 특정 데이터베이스 테이블을 대상으로 쿼리를 날리면 해당 데이터베이스에 종속적인 설계로 이루어진다 하지만 JPQL를
  사용함으로써 특정 DB에 종속적이지 않은 쿼리를 작성할 수 있다.
- JPQL를 통해 엔티티 객체를 중심으로 개발할 수 있다.</br></br></br></br>





# Chapter 2. Persistence Context
1. EntityManagerFactory & EntityManager
- EntityManagerFactory를 통해 고객의 요청이 올 때마다 새로운 EntityManager를 생성한다.
- EntityManager는 내부적으로 데이터베이스 커넥션을 사용해서 데이터베이스와 통신하게 된다.</br></br></br>



2. Persistence Context?
- 엔티티를 영구적으로 저장하는 환경이라는 뜻을 가지고 있으며 가시적이지 않은 논리적인 개념이다.</br></br>
- EntityManager를 통해 영속성 컨텍스트에 접근할 수 있다.</br></br>
- em.persist(entity); 코드의 경우 실제 데이터베이스에 저장한다는 것이 아니라 영속성 컨텍스트를 통해서
  해당 엔티티를 영속화(영속성 컨텍스트에 저장)한다는 의미를 가지고 있다.</br></br></br>



3. 엔티티의 생명주기</br>
(1) 비영속(new/transient) 상태
- 영속성 컨텍스트와 전혀 연관 없는 상태</br></br>
(2) 영속(managed) 상태
- 영속성 컨텍스트에 의해 관리되는 상태</br></br>
(3) 준영속(detached) 상태
- 영속성 컨텍스트에서 저장되었다가 분리된 상태</br></br>
(4) 삭제(Removed) 상태
- 삭제된 상태</br></br></br>


4. Persistence Context의 이점</br>
4-1. 1차 캐시</br></br
(1) 엔티티를 영속화하거나 처음 조회한다면 영속성 컨텍스트 내부에 1차 캐시로 해당 엔티티에 대한 스냅샷 정보를 저장해둔다. </br></br>
(2) 1차 캐시에 엔티티가 없다면 직접 데이터베이스를 조회하여 관련 엔티티를 1차 캐시에 저장한다.</br></br></br>


4-2. 영속 엔티티의 동일성 보장</br>
(1) JPA가 동일 트랜잭션 내부에서 영속화된 엔티티의 동일성을 보장해준다. 마치 자바 컬렉션에서 똑같은 참조 주소를 가지고 있는 객체에 대해 == 비교를 한 것과 동일한 상황이다.</br></br>


4-3. 트랜잭션을 지원하는 쓰기 지연</br>
(1) 영속성 컨텍스트 내부엔 쓰기 지연 저장소라는 공간이 존재한다. </br></br>
(2) 엔티티가 영속화되는 순간 연관된 INSERT SQL를 쓰기 지연 저장소에 보관한다. </br></br>
(3) 트랜잭션을 커밋하는 순간 flush가 발생되어 쓰기 지연 저장소에 보관되어 있던 INSERT SQL이 실제 DB로 전송되고 커밋이 진행된다. </br></br></br>


4-4. 엔티티 수정 시 발생하는 변경 감지(Dirty checking)</br>
(1) 트랜잭션 커밋 시점에 내부적으로 Flush가 호출된다.</br></br>
(2) Flush가 발생하면, 해당 엔티티의 초기 스냅샷(영속성 컨텍스트에 처음 영속화됐을 당시의 데이터)과 엔티티의 수정 사항을 비교한다.</br></br>
(3) 엔티티의 스냅샷과 수정 사항을 비교해서 변경사항이 존재한다면 쓰기 지연 저장소에 UPDATE SQL를 저장해두고 이를 실제 DB에 보내면서 커밋이 진행된다.</br></br>
(4) 이러한 일련의 과정들을 변경 감지(Dirty checking)이라고 한다.</br></br></br></br></br>




5. Flush(플러시)란 무엇일까?</br>
(1) 플러시는 영속성 컨텍스트의 변경 내용과 실제 물리적 데이터베이스의 내용이 일치하도록 반영하는 작업을 의미하고 있다.</br></br>
(2) 일반적으로 데이터베이스 커밋 시점에 플러시가 발생하게 된다.</br></br>
(3) 트랜잭션이라는 작업 단위가 중요하고, 커밋 직전에만 데이터베이스와 동기화해주면 된다는 특징이 있다.</br></br></br>


5-1. 영속성 컨텍스트를 플러시하는 방법?</br>
(1) em.flush()</br></br>
(2) 트랜잭션 커밋 시점</br></br>
(3) JPQL 쿼리를 날린 경우 </br></br></br>


5-2. 플러시 모드 옵션</br>
(1) FlushModeType.AUTO (기본값)
- 커밋, 쿼리를 실행할 때 플러시 실행 </br></br>

(2) FlushModeType.COMMIT
- 커밋 시점에서만 플러시 실행</br></br></br></br></br>




6. 준영속 상태</br>
(1) 영속 상태의 엔티티가 영속성 컨텍스트에서 분리되는 것을 말한다. 이럴 경우 영속성 컨텍스트가 제공하는 기능(변경 감지 등)을 사용할 수 없게 된다. </br></br>

6-1. 준영속 상태로 전환하는 방법</br>
(1) em.detach(entity);
- 특정 엔티티만 준영속 상태로 전환 </br></br>
(2) em.clear();
- 영속성 컨텍스트를 완전히 초기화</br></br>
(3) em.close();
- 영속성 컨텍스트를 종료한다.</br></br></br></br></br>






# Chapter 3. Entity Mapping
JPA에서 중요한 부분 2가지 : JPA 동작 방식(영속성 컨텍스트) 이해, 설계적인 측면에서 객체와 데이터베이스 테이블을 정확히 매핑하는 것 </br></br>
객체와 테이블 매핑 : @Entity, @Table</br>
필드와 컬럼 매핑 : @Column</br>
기본 키 매핑 : @Id</br>
연관관계 매핑 : @ManyToOne, @JoinColumn ... 등</br></br>

6-1. 객체와 테이블 매핑</br>
(1) @Entity가 붙은 클래스는 JPA가 관리하는 엔티티라고 부른다.</br></br>
(2) JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션이 필수이다.</br></br>
(3) JPA 스펙 상, 기본 생성자(public, protected)가 필수적이다.</br></br></br></br>






# Chapter 4. 연관관계 Mapping : 1:1 1:n n:1 n:n
(1) 연관관계 매핑에서 가장 중요한 것? : 객체와 테이블 연관관계의 차이를 이해, 객체의 참조와 테이블 외래 키를 정확히 매핑하는 것</br></br>
(2) 연관관계란? : 객체 또는 테이블이 서로 논리적인 의미를 갖고 양쪽을 서로 참조하는 것을 말함</br></br>
(3) 주요 용어 : 단방향, 양방향,  1:1 1:n n:1 n:n, 연관관계의 주인 설정</br></br></br></br>



4-1. 객체를 테이블에 맞추어 데이터 중심으로 모델링 시 객체 간의 협력 관계를 만들 수 없다.</br></br>
(1) 테이블은 외래 키로 JOIN을 통해 연관 테이블을 탐색한다.</br></br>
(2) 하지만 객체는 참조를 사용해서 연관된 객체를 탐색하게 된다(객체와 테이블 간의 패러다임 불일치라는 큰 간격이 발생한다)</br></br>
(3) 어떻게 해결할 수 있을까? : 객체의 참조와 데이터베이스 테이블의 외래 키를 매핑해서 연관관계를 설정함으로써 패러다임 불일치를 해결한다.</br></br></br></br>



4-2. 연관관계의 주인 : mappedBy </br></br>
(1) 객체와 테이블 간의 연관관계를 맺는 차이를 이해해야 함</br></br>
(2) 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개가 존재하는 것</br></br>
(3) 양방향 연관관계에서는 객체의 두 관계 중 하나를 연관관계의 주인으로 설정해야 한다. </br></br>
(4) 연관관계의 주인이 된 객체만이 외래 키를 관리(등록, 수정)한다. 주인이 아닌 쪽은 조회만 가능.</br></br>
(5) mappedBy가 적용된 객체는 조회만 가능, 등록, 수정, 삭제의 경우 연관관계의 주인이 된 객체에서만 가능하다.</br></br></br></br>



4-3. 누구를 연관관계의 주인으로 설정할까?</br></br> 
(1) 외래 키를 가지고 있는 객체를 연관관계의 주인으로 설정한다. (1:N 관계에서 N을 가지는 객체)</br></br></br></br>




4-4. 양방향 연관관계 주의사항</br></br>
(1) 순수 객체 상태를 고려해서 객체 양방향에 값을 설정</br></br>
(2) 1 또는 N쪽에 연관관계 편의 메서드를 별도로 설정한다.</br></br>
(3) 양방향 매핑 시 무한 루프를 주의한다.</br></br></br></br>



4-5. 양방향 매핑 정리 </br></br>
(1) 단방향 매핑 관계를 설정하는 것만으로도 사실상 연관관계 매핑은 완료된다.</br></br>
(2) 양방향 매핑은 단지 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐이다.</br></br>
(3) 단방향 매핑을 올바르게 지정하고 이후 필요 시 양방향 매핑을 추가한다.</br></br>
(4) 핵심은 단방향 매핑을 올바르게 지정하는 것이다. 실무에서는 복잡한 JPQL(조회)을 많이 설계해야 하는 일이 있는데 이럴 때 단방향 연관관계보다 양방향 연관관계가 필요한 경우가 많다.
가능하면 최대한 단방향으로 설계하며 코드를 조금 더 객체지향적으로 설계해야 하는 일이 생기다 보면 비즈니스상 양방향 연관관계가 더 수월한 경우가 있을 때
양방향 연관관계를 설정한다. </br></br></br></br>




4-6. 연관관계의 주인을 정하는 기준</br></br>
(1) 비즈니스 로직을 기준으로 정하는 것이 외래 키의 위치를 기준으로 정해야 한다.</br></br>
(2) JPA보다 중요한 부분은 사실상 관계형 데이터베이스의 근본적인 이해가 선행되어어 한다.</br></br></br></br></br>






# Chapter 5. 다양한 연관관계 Mapping</br>
5-1. 연관관계 매핑 시 고려할 사항 3가지</br>
(1) 다중성 : @ManyToOne, @OneToMany, @OneToOne, @ManyToMany (JPA의 어노테이션은 DB와의 매핑을 위해 사용된다. 데이터베이스의 다중성 관점에서 생각한다.)</br></br></br>


(2) 단방향과 양방향</br>
- 테이블 : 외래 키 하나로 양쪽을 모두 JOIN 할 수 있다. 따라서 방향이라는 개념이 존재하지 않는다.</br></br>
- 객체 : 참조 필드가 있는 쪽으로만 참조가 가능하다. 한 쪽만 참조하면 단방향, 양쪽이 서로 참조하면 양방향 관계(단방향이 양 쪽으로 모두 존재하는 것) </br></br></br>


(3) 연관관계의 주인</br>
- 테이블은 외래 키 하나로 두 테이블이 모두 연관관계를 구성한다.</br></br>
- 객체의 양방향 관계는 A -> B, B -> A처럼 참조 영역이 2개</br></br>
- 객체의 양방향 관계는 참조가 2개 존재, 둘 중 테이블의 외래 키를 관리할 곳을 지정해야 한다.</br></br>
- 연관관계의 주인은 외래 키를 관리하는 참조를 가진 객체가 연관관계의 주인이 된다.</br></br>
- 주인의 반대편은 외래 키에 영향을 주지 않고 단순 조회만 가능하다.</br></br></br></br>




5-2. 다대일(N:1) 단방향</br>
(1) 테이블 설계상, N쪽에 외래 키가 존재해야 한다.</br></br>
(2) 외래 키가 존재하는 곳에 참조를 걸고 연관관계 매핑을 설정해 준다.</br></br>
(3) 가장 많이 사용되는 연관관계로 반대는 N:1</br></br></br></br>



5-3. 다대일(N:1) 양방향</br>
(1) 외래 키가 존재하는 곳이 연관관계의 주인이 된다.(N쪽)</br></br>
(2) 양쪽을 서로 참조하도록 개발할 때 필요하다.</br></br></br></br>

